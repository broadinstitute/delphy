// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_API_DELPHY_API_H_
#define FLATBUFFERS_GENERATED_API_DELPHY_API_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

namespace delphy {
namespace api {

struct Node;

struct Mutation;

struct MissationInterval;

struct Tree;
struct TreeBuilder;

struct NodeInfo;
struct NodeInfoBuilder;

struct TreeInfo;
struct TreeInfoBuilder;

struct ExpPopModel;
struct ExpPopModelBuilder;

struct SkygridPopModel;
struct SkygridPopModelBuilder;

struct Params;
struct ParamsBuilder;

enum RealSeqLetter : uint8_t {
  RealSeqLetter_A = 0,
  RealSeqLetter_C = 1,
  RealSeqLetter_G = 2,
  RealSeqLetter_T = 3,
  RealSeqLetter_MIN = RealSeqLetter_A,
  RealSeqLetter_MAX = RealSeqLetter_T
};

inline const RealSeqLetter (&EnumValuesRealSeqLetter())[4] {
  static const RealSeqLetter values[] = {
    RealSeqLetter_A,
    RealSeqLetter_C,
    RealSeqLetter_G,
    RealSeqLetter_T
  };
  return values;
}

inline const char * const *EnumNamesRealSeqLetter() {
  static const char * const names[5] = {
    "A",
    "C",
    "G",
    "T",
    nullptr
  };
  return names;
}

inline const char *EnumNameRealSeqLetter(RealSeqLetter e) {
  if (::flatbuffers::IsOutRange(e, RealSeqLetter_A, RealSeqLetter_T)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRealSeqLetter()[index];
}

enum SkygridType : int8_t {
  SkygridType_Staircase = 1,
  SkygridType_LogLinear = 2,
  SkygridType_MIN = SkygridType_Staircase,
  SkygridType_MAX = SkygridType_LogLinear
};

inline const SkygridType (&EnumValuesSkygridType())[2] {
  static const SkygridType values[] = {
    SkygridType_Staircase,
    SkygridType_LogLinear
  };
  return values;
}

inline const char * const *EnumNamesSkygridType() {
  static const char * const names[3] = {
    "Staircase",
    "LogLinear",
    nullptr
  };
  return names;
}

inline const char *EnumNameSkygridType(SkygridType e) {
  if (::flatbuffers::IsOutRange(e, SkygridType_Staircase, SkygridType_LogLinear)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(SkygridType_Staircase);
  return EnumNamesSkygridType()[index];
}

enum PopModel : uint8_t {
  PopModel_NONE = 0,
  PopModel_ExpPopModel = 1,
  PopModel_SkygridPopModel = 2,
  PopModel_MIN = PopModel_NONE,
  PopModel_MAX = PopModel_SkygridPopModel
};

inline const PopModel (&EnumValuesPopModel())[3] {
  static const PopModel values[] = {
    PopModel_NONE,
    PopModel_ExpPopModel,
    PopModel_SkygridPopModel
  };
  return values;
}

inline const char * const *EnumNamesPopModel() {
  static const char * const names[4] = {
    "NONE",
    "ExpPopModel",
    "SkygridPopModel",
    nullptr
  };
  return names;
}

inline const char *EnumNamePopModel(PopModel e) {
  if (::flatbuffers::IsOutRange(e, PopModel_NONE, PopModel_SkygridPopModel)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPopModel()[index];
}

template<typename T> struct PopModelTraits {
  static const PopModel enum_value = PopModel_NONE;
};

template<> struct PopModelTraits<delphy::api::ExpPopModel> {
  static const PopModel enum_value = PopModel_ExpPopModel;
};

template<> struct PopModelTraits<delphy::api::SkygridPopModel> {
  static const PopModel enum_value = PopModel_SkygridPopModel;
};

bool VerifyPopModel(::flatbuffers::Verifier &verifier, const void *obj, PopModel type);
bool VerifyPopModelVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Node FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t parent_;
  int32_t left_child_;
  int32_t right_child_;
  float t_;

 public:
  Node()
      : parent_(0),
        left_child_(0),
        right_child_(0),
        t_(0) {
  }
  Node(int32_t _parent, int32_t _left_child, int32_t _right_child, float _t)
      : parent_(::flatbuffers::EndianScalar(_parent)),
        left_child_(::flatbuffers::EndianScalar(_left_child)),
        right_child_(::flatbuffers::EndianScalar(_right_child)),
        t_(::flatbuffers::EndianScalar(_t)) {
  }
  int32_t parent() const {
    return ::flatbuffers::EndianScalar(parent_);
  }
  int32_t left_child() const {
    return ::flatbuffers::EndianScalar(left_child_);
  }
  int32_t right_child() const {
    return ::flatbuffers::EndianScalar(right_child_);
  }
  float t() const {
    return ::flatbuffers::EndianScalar(t_);
  }
};
FLATBUFFERS_STRUCT_END(Node, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Mutation FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t branch_;
  int32_t site_;
  uint8_t from_;
  uint8_t to_;
  int16_t padding0__;
  float t_;

 public:
  Mutation()
      : branch_(0),
        site_(0),
        from_(0),
        to_(0),
        padding0__(0),
        t_(0) {
    (void)padding0__;
  }
  Mutation(int32_t _branch, int32_t _site, delphy::api::RealSeqLetter _from, delphy::api::RealSeqLetter _to, float _t)
      : branch_(::flatbuffers::EndianScalar(_branch)),
        site_(::flatbuffers::EndianScalar(_site)),
        from_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_from))),
        to_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_to))),
        padding0__(0),
        t_(::flatbuffers::EndianScalar(_t)) {
    (void)padding0__;
  }
  int32_t branch() const {
    return ::flatbuffers::EndianScalar(branch_);
  }
  int32_t site() const {
    return ::flatbuffers::EndianScalar(site_);
  }
  delphy::api::RealSeqLetter from() const {
    return static_cast<delphy::api::RealSeqLetter>(::flatbuffers::EndianScalar(from_));
  }
  delphy::api::RealSeqLetter to() const {
    return static_cast<delphy::api::RealSeqLetter>(::flatbuffers::EndianScalar(to_));
  }
  float t() const {
    return ::flatbuffers::EndianScalar(t_);
  }
};
FLATBUFFERS_STRUCT_END(Mutation, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) MissationInterval FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t branch_;
  int32_t start_site_;
  int32_t end_site_;

 public:
  MissationInterval()
      : branch_(0),
        start_site_(0),
        end_site_(0) {
  }
  MissationInterval(int32_t _branch, int32_t _start_site, int32_t _end_site)
      : branch_(::flatbuffers::EndianScalar(_branch)),
        start_site_(::flatbuffers::EndianScalar(_start_site)),
        end_site_(::flatbuffers::EndianScalar(_end_site)) {
  }
  int32_t branch() const {
    return ::flatbuffers::EndianScalar(branch_);
  }
  int32_t start_site() const {
    return ::flatbuffers::EndianScalar(start_site_);
  }
  int32_t end_site() const {
    return ::flatbuffers::EndianScalar(end_site_);
  }
};
FLATBUFFERS_STRUCT_END(MissationInterval, 12);

struct Tree FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TreeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODES = 4,
    VT_MUTATIONS = 6,
    VT_MISSATION_INTERVALS = 8,
    VT_REF_SEQ = 10,
    VT_ROOT_NODE = 12
  };
  const ::flatbuffers::Vector<const delphy::api::Node *> *nodes() const {
    return GetPointer<const ::flatbuffers::Vector<const delphy::api::Node *> *>(VT_NODES);
  }
  const ::flatbuffers::Vector<const delphy::api::Mutation *> *mutations() const {
    return GetPointer<const ::flatbuffers::Vector<const delphy::api::Mutation *> *>(VT_MUTATIONS);
  }
  const ::flatbuffers::Vector<const delphy::api::MissationInterval *> *missation_intervals() const {
    return GetPointer<const ::flatbuffers::Vector<const delphy::api::MissationInterval *> *>(VT_MISSATION_INTERVALS);
  }
  const ::flatbuffers::Vector<uint8_t> *ref_seq() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_REF_SEQ);
  }
  int32_t root_node() const {
    return GetField<int32_t>(VT_ROOT_NODE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           VerifyOffset(verifier, VT_MUTATIONS) &&
           verifier.VerifyVector(mutations()) &&
           VerifyOffset(verifier, VT_MISSATION_INTERVALS) &&
           verifier.VerifyVector(missation_intervals()) &&
           VerifyOffset(verifier, VT_REF_SEQ) &&
           verifier.VerifyVector(ref_seq()) &&
           VerifyField<int32_t>(verifier, VT_ROOT_NODE, 4) &&
           verifier.EndTable();
  }
};

struct TreeBuilder {
  typedef Tree Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<const delphy::api::Node *>> nodes) {
    fbb_.AddOffset(Tree::VT_NODES, nodes);
  }
  void add_mutations(::flatbuffers::Offset<::flatbuffers::Vector<const delphy::api::Mutation *>> mutations) {
    fbb_.AddOffset(Tree::VT_MUTATIONS, mutations);
  }
  void add_missation_intervals(::flatbuffers::Offset<::flatbuffers::Vector<const delphy::api::MissationInterval *>> missation_intervals) {
    fbb_.AddOffset(Tree::VT_MISSATION_INTERVALS, missation_intervals);
  }
  void add_ref_seq(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ref_seq) {
    fbb_.AddOffset(Tree::VT_REF_SEQ, ref_seq);
  }
  void add_root_node(int32_t root_node) {
    fbb_.AddElement<int32_t>(Tree::VT_ROOT_NODE, root_node, 0);
  }
  explicit TreeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tree> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tree>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tree> CreateTree(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const delphy::api::Node *>> nodes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const delphy::api::Mutation *>> mutations = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const delphy::api::MissationInterval *>> missation_intervals = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ref_seq = 0,
    int32_t root_node = 0) {
  TreeBuilder builder_(_fbb);
  builder_.add_root_node(root_node);
  builder_.add_ref_seq(ref_seq);
  builder_.add_missation_intervals(missation_intervals);
  builder_.add_mutations(mutations);
  builder_.add_nodes(nodes);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tree> CreateTreeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<delphy::api::Node> *nodes = nullptr,
    const std::vector<delphy::api::Mutation> *mutations = nullptr,
    const std::vector<delphy::api::MissationInterval> *missation_intervals = nullptr,
    const std::vector<uint8_t> *ref_seq = nullptr,
    int32_t root_node = 0) {
  auto nodes__ = nodes ? _fbb.CreateVectorOfStructs<delphy::api::Node>(*nodes) : 0;
  auto mutations__ = mutations ? _fbb.CreateVectorOfStructs<delphy::api::Mutation>(*mutations) : 0;
  auto missation_intervals__ = missation_intervals ? _fbb.CreateVectorOfStructs<delphy::api::MissationInterval>(*missation_intervals) : 0;
  auto ref_seq__ = ref_seq ? _fbb.CreateVector<uint8_t>(*ref_seq) : 0;
  return delphy::api::CreateTree(
      _fbb,
      nodes__,
      mutations__,
      missation_intervals__,
      ref_seq__,
      root_node);
}

struct NodeInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodeInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_HAS_UNCERTAIN_T = 6,
    VT_T_MIN = 8,
    VT_T_MAX = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool has_uncertain_t() const {
    return GetField<uint8_t>(VT_HAS_UNCERTAIN_T, 0) != 0;
  }
  float t_min() const {
    return GetField<float>(VT_T_MIN, 0.0f);
  }
  float t_max() const {
    return GetField<float>(VT_T_MAX, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_HAS_UNCERTAIN_T, 1) &&
           VerifyField<float>(verifier, VT_T_MIN, 4) &&
           VerifyField<float>(verifier, VT_T_MAX, 4) &&
           verifier.EndTable();
  }
};

struct NodeInfoBuilder {
  typedef NodeInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NodeInfo::VT_NAME, name);
  }
  void add_has_uncertain_t(bool has_uncertain_t) {
    fbb_.AddElement<uint8_t>(NodeInfo::VT_HAS_UNCERTAIN_T, static_cast<uint8_t>(has_uncertain_t), 0);
  }
  void add_t_min(float t_min) {
    fbb_.AddElement<float>(NodeInfo::VT_T_MIN, t_min, 0.0f);
  }
  void add_t_max(float t_max) {
    fbb_.AddElement<float>(NodeInfo::VT_T_MAX, t_max, 0.0f);
  }
  explicit NodeInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NodeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NodeInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NodeInfo> CreateNodeInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    bool has_uncertain_t = false,
    float t_min = 0.0f,
    float t_max = 0.0f) {
  NodeInfoBuilder builder_(_fbb);
  builder_.add_t_max(t_max);
  builder_.add_t_min(t_min);
  builder_.add_name(name);
  builder_.add_has_uncertain_t(has_uncertain_t);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NodeInfo> CreateNodeInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool has_uncertain_t = false,
    float t_min = 0.0f,
    float t_max = 0.0f) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return delphy::api::CreateNodeInfo(
      _fbb,
      name__,
      has_uncertain_t,
      t_min,
      t_max);
}

struct TreeInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TreeInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_INFOS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<delphy::api::NodeInfo>> *node_infos() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<delphy::api::NodeInfo>> *>(VT_NODE_INFOS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODE_INFOS) &&
           verifier.VerifyVector(node_infos()) &&
           verifier.VerifyVectorOfTables(node_infos()) &&
           verifier.EndTable();
  }
};

struct TreeInfoBuilder {
  typedef TreeInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_node_infos(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<delphy::api::NodeInfo>>> node_infos) {
    fbb_.AddOffset(TreeInfo::VT_NODE_INFOS, node_infos);
  }
  explicit TreeInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TreeInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TreeInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TreeInfo> CreateTreeInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<delphy::api::NodeInfo>>> node_infos = 0) {
  TreeInfoBuilder builder_(_fbb);
  builder_.add_node_infos(node_infos);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TreeInfo> CreateTreeInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<delphy::api::NodeInfo>> *node_infos = nullptr) {
  auto node_infos__ = node_infos ? _fbb.CreateVector<::flatbuffers::Offset<delphy::api::NodeInfo>>(*node_infos) : 0;
  return delphy::api::CreateTreeInfo(
      _fbb,
      node_infos__);
}

struct ExpPopModel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExpPopModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T0 = 4,
    VT_N0 = 6,
    VT_G = 8
  };
  double t0() const {
    return GetField<double>(VT_T0, 0.0);
  }
  double n0() const {
    return GetField<double>(VT_N0, 0.0);
  }
  double g() const {
    return GetField<double>(VT_G, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_T0, 8) &&
           VerifyField<double>(verifier, VT_N0, 8) &&
           VerifyField<double>(verifier, VT_G, 8) &&
           verifier.EndTable();
  }
};

struct ExpPopModelBuilder {
  typedef ExpPopModel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_t0(double t0) {
    fbb_.AddElement<double>(ExpPopModel::VT_T0, t0, 0.0);
  }
  void add_n0(double n0) {
    fbb_.AddElement<double>(ExpPopModel::VT_N0, n0, 0.0);
  }
  void add_g(double g) {
    fbb_.AddElement<double>(ExpPopModel::VT_G, g, 0.0);
  }
  explicit ExpPopModelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExpPopModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExpPopModel>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExpPopModel> CreateExpPopModel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double t0 = 0.0,
    double n0 = 0.0,
    double g = 0.0) {
  ExpPopModelBuilder builder_(_fbb);
  builder_.add_g(g);
  builder_.add_n0(n0);
  builder_.add_t0(t0);
  return builder_.Finish();
}

struct SkygridPopModel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SkygridPopModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_X_K = 6,
    VT_GAMMA_K = 8
  };
  delphy::api::SkygridType type() const {
    return static_cast<delphy::api::SkygridType>(GetField<int8_t>(VT_TYPE, 1));
  }
  const ::flatbuffers::Vector<double> *x_k() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_X_K);
  }
  const ::flatbuffers::Vector<double> *gamma_k() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_GAMMA_K);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_X_K) &&
           verifier.VerifyVector(x_k()) &&
           VerifyOffset(verifier, VT_GAMMA_K) &&
           verifier.VerifyVector(gamma_k()) &&
           verifier.EndTable();
  }
};

struct SkygridPopModelBuilder {
  typedef SkygridPopModel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(delphy::api::SkygridType type) {
    fbb_.AddElement<int8_t>(SkygridPopModel::VT_TYPE, static_cast<int8_t>(type), 1);
  }
  void add_x_k(::flatbuffers::Offset<::flatbuffers::Vector<double>> x_k) {
    fbb_.AddOffset(SkygridPopModel::VT_X_K, x_k);
  }
  void add_gamma_k(::flatbuffers::Offset<::flatbuffers::Vector<double>> gamma_k) {
    fbb_.AddOffset(SkygridPopModel::VT_GAMMA_K, gamma_k);
  }
  explicit SkygridPopModelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SkygridPopModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SkygridPopModel>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SkygridPopModel> CreateSkygridPopModel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    delphy::api::SkygridType type = delphy::api::SkygridType_Staircase,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> x_k = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> gamma_k = 0) {
  SkygridPopModelBuilder builder_(_fbb);
  builder_.add_gamma_k(gamma_k);
  builder_.add_x_k(x_k);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SkygridPopModel> CreateSkygridPopModelDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    delphy::api::SkygridType type = delphy::api::SkygridType_Staircase,
    const std::vector<double> *x_k = nullptr,
    const std::vector<double> *gamma_k = nullptr) {
  auto x_k__ = x_k ? _fbb.CreateVector<double>(*x_k) : 0;
  auto gamma_k__ = gamma_k ? _fbb.CreateVector<double>(*gamma_k) : 0;
  return delphy::api::CreateSkygridPopModel(
      _fbb,
      type,
      x_k__,
      gamma_k__);
}

struct Params FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParamsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STEP = 4,
    VT_NUM_LOCAL_MOVES_PER_GLOBAL_MOVE = 6,
    VT_NUM_PARTS = 8,
    VT_MU = 10,
    VT_ALPHA = 12,
    VT_NU = 14,
    VT_HKY_KAPPA = 16,
    VT_HKY_PI_A = 18,
    VT_HKY_PI_C = 20,
    VT_HKY_PI_G = 22,
    VT_HKY_PI_T = 24,
    VT_POP_N0 = 26,
    VT_POP_G = 28,
    VT_ONLY_DISPLACING_INNER_NODES = 30,
    VT_TOPOLOGY_MOVES_ENABLED = 32,
    VT_REPARTITIONING_ENABLED = 34,
    VT_ALPHA_MOVE_ENABLED = 36,
    VT_LOG_POSTERIOR = 38,
    VT_LOG_OTHER_PRIORS = 40,
    VT_LOG_COALESCENT_PRIOR = 42,
    VT_LOG_G = 44,
    VT_TOTAL_BRANCH_LENGTH = 46,
    VT_MPOX_HACK_ENABLED = 48,
    VT_MPOX_MU = 50,
    VT_MPOX_MU_STAR = 52,
    VT_MU_MOVE_ENABLED = 54,
    VT_POP_T0 = 56,
    VT_FINAL_POP_SIZE_MOVE_ENABLED = 58,
    VT_POP_GROWTH_RATE_MOVE_ENABLED = 60,
    VT_POP_MODEL_TYPE = 62,
    VT_POP_MODEL = 64,
    VT_SKYGRID_TAU = 66,
    VT_SKYGRID_TAU_PRIOR_ALPHA = 68,
    VT_SKYGRID_TAU_PRIOR_BETA = 70,
    VT_SKYGRID_TAU_MOVE_ENABLED = 72,
    VT_SKYGRID_LOW_GAMMA_BARRIER_ENABLED = 74,
    VT_SKYGRID_LOW_GAMMA_BARRIER_LOC = 76,
    VT_SKYGRID_LOW_GAMMA_BARRIER_SCALE = 78
  };
  int64_t step() const {
    return GetField<int64_t>(VT_STEP, 0);
  }
  int64_t num_local_moves_per_global_move() const {
    return GetField<int64_t>(VT_NUM_LOCAL_MOVES_PER_GLOBAL_MOVE, -1LL);
  }
  int32_t num_parts() const {
    return GetField<int32_t>(VT_NUM_PARTS, 0);
  }
  double mu() const {
    return GetField<double>(VT_MU, 0.0);
  }
  double alpha() const {
    return GetField<double>(VT_ALPHA, 0.0);
  }
  const ::flatbuffers::Vector<double> *nu() const {
    return GetPointer<const ::flatbuffers::Vector<double> *>(VT_NU);
  }
  double hky_kappa() const {
    return GetField<double>(VT_HKY_KAPPA, 0.0);
  }
  double hky_pi_A() const {
    return GetField<double>(VT_HKY_PI_A, 0.0);
  }
  double hky_pi_C() const {
    return GetField<double>(VT_HKY_PI_C, 0.0);
  }
  double hky_pi_G() const {
    return GetField<double>(VT_HKY_PI_G, 0.0);
  }
  double hky_pi_T() const {
    return GetField<double>(VT_HKY_PI_T, 0.0);
  }
  double pop_n0() const {
    return GetField<double>(VT_POP_N0, 0.0);
  }
  double pop_g() const {
    return GetField<double>(VT_POP_G, 0.0);
  }
  bool only_displacing_inner_nodes() const {
    return GetField<uint8_t>(VT_ONLY_DISPLACING_INNER_NODES, 0) != 0;
  }
  bool topology_moves_enabled() const {
    return GetField<uint8_t>(VT_TOPOLOGY_MOVES_ENABLED, 0) != 0;
  }
  bool repartitioning_enabled() const {
    return GetField<uint8_t>(VT_REPARTITIONING_ENABLED, 0) != 0;
  }
  bool alpha_move_enabled() const {
    return GetField<uint8_t>(VT_ALPHA_MOVE_ENABLED, 0) != 0;
  }
  double log_posterior() const {
    return GetField<double>(VT_LOG_POSTERIOR, 0.0);
  }
  double log_other_priors() const {
    return GetField<double>(VT_LOG_OTHER_PRIORS, 0.0);
  }
  double log_coalescent_prior() const {
    return GetField<double>(VT_LOG_COALESCENT_PRIOR, 0.0);
  }
  double log_G() const {
    return GetField<double>(VT_LOG_G, 0.0);
  }
  double total_branch_length() const {
    return GetField<double>(VT_TOTAL_BRANCH_LENGTH, 0.0);
  }
  bool mpox_hack_enabled() const {
    return GetField<uint8_t>(VT_MPOX_HACK_ENABLED, 0) != 0;
  }
  double mpox_mu() const {
    return GetField<double>(VT_MPOX_MU, 0.0);
  }
  double mpox_mu_star() const {
    return GetField<double>(VT_MPOX_MU_STAR, 0.0);
  }
  bool mu_move_enabled() const {
    return GetField<uint8_t>(VT_MU_MOVE_ENABLED, 1) != 0;
  }
  double pop_t0() const {
    return GetField<double>(VT_POP_T0, 0.0);
  }
  bool final_pop_size_move_enabled() const {
    return GetField<uint8_t>(VT_FINAL_POP_SIZE_MOVE_ENABLED, 1) != 0;
  }
  bool pop_growth_rate_move_enabled() const {
    return GetField<uint8_t>(VT_POP_GROWTH_RATE_MOVE_ENABLED, 1) != 0;
  }
  delphy::api::PopModel pop_model_type() const {
    return static_cast<delphy::api::PopModel>(GetField<uint8_t>(VT_POP_MODEL_TYPE, 0));
  }
  const void *pop_model() const {
    return GetPointer<const void *>(VT_POP_MODEL);
  }
  template<typename T> const T *pop_model_as() const;
  const delphy::api::ExpPopModel *pop_model_as_ExpPopModel() const {
    return pop_model_type() == delphy::api::PopModel_ExpPopModel ? static_cast<const delphy::api::ExpPopModel *>(pop_model()) : nullptr;
  }
  const delphy::api::SkygridPopModel *pop_model_as_SkygridPopModel() const {
    return pop_model_type() == delphy::api::PopModel_SkygridPopModel ? static_cast<const delphy::api::SkygridPopModel *>(pop_model()) : nullptr;
  }
  double skygrid_tau() const {
    return GetField<double>(VT_SKYGRID_TAU, 0.0);
  }
  double skygrid_tau_prior_alpha() const {
    return GetField<double>(VT_SKYGRID_TAU_PRIOR_ALPHA, 0.0);
  }
  double skygrid_tau_prior_beta() const {
    return GetField<double>(VT_SKYGRID_TAU_PRIOR_BETA, 0.0);
  }
  bool skygrid_tau_move_enabled() const {
    return GetField<uint8_t>(VT_SKYGRID_TAU_MOVE_ENABLED, 0) != 0;
  }
  bool skygrid_low_gamma_barrier_enabled() const {
    return GetField<uint8_t>(VT_SKYGRID_LOW_GAMMA_BARRIER_ENABLED, 0) != 0;
  }
  double skygrid_low_gamma_barrier_loc() const {
    return GetField<double>(VT_SKYGRID_LOW_GAMMA_BARRIER_LOC, 0.0);
  }
  double skygrid_low_gamma_barrier_scale() const {
    return GetField<double>(VT_SKYGRID_LOW_GAMMA_BARRIER_SCALE, 0.0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_STEP, 8) &&
           VerifyField<int64_t>(verifier, VT_NUM_LOCAL_MOVES_PER_GLOBAL_MOVE, 8) &&
           VerifyField<int32_t>(verifier, VT_NUM_PARTS, 4) &&
           VerifyField<double>(verifier, VT_MU, 8) &&
           VerifyField<double>(verifier, VT_ALPHA, 8) &&
           VerifyOffset(verifier, VT_NU) &&
           verifier.VerifyVector(nu()) &&
           VerifyField<double>(verifier, VT_HKY_KAPPA, 8) &&
           VerifyField<double>(verifier, VT_HKY_PI_A, 8) &&
           VerifyField<double>(verifier, VT_HKY_PI_C, 8) &&
           VerifyField<double>(verifier, VT_HKY_PI_G, 8) &&
           VerifyField<double>(verifier, VT_HKY_PI_T, 8) &&
           VerifyField<double>(verifier, VT_POP_N0, 8) &&
           VerifyField<double>(verifier, VT_POP_G, 8) &&
           VerifyField<uint8_t>(verifier, VT_ONLY_DISPLACING_INNER_NODES, 1) &&
           VerifyField<uint8_t>(verifier, VT_TOPOLOGY_MOVES_ENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_REPARTITIONING_ENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_ALPHA_MOVE_ENABLED, 1) &&
           VerifyField<double>(verifier, VT_LOG_POSTERIOR, 8) &&
           VerifyField<double>(verifier, VT_LOG_OTHER_PRIORS, 8) &&
           VerifyField<double>(verifier, VT_LOG_COALESCENT_PRIOR, 8) &&
           VerifyField<double>(verifier, VT_LOG_G, 8) &&
           VerifyField<double>(verifier, VT_TOTAL_BRANCH_LENGTH, 8) &&
           VerifyField<uint8_t>(verifier, VT_MPOX_HACK_ENABLED, 1) &&
           VerifyField<double>(verifier, VT_MPOX_MU, 8) &&
           VerifyField<double>(verifier, VT_MPOX_MU_STAR, 8) &&
           VerifyField<uint8_t>(verifier, VT_MU_MOVE_ENABLED, 1) &&
           VerifyField<double>(verifier, VT_POP_T0, 8) &&
           VerifyField<uint8_t>(verifier, VT_FINAL_POP_SIZE_MOVE_ENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_POP_GROWTH_RATE_MOVE_ENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_POP_MODEL_TYPE, 1) &&
           VerifyOffset(verifier, VT_POP_MODEL) &&
           VerifyPopModel(verifier, pop_model(), pop_model_type()) &&
           VerifyField<double>(verifier, VT_SKYGRID_TAU, 8) &&
           VerifyField<double>(verifier, VT_SKYGRID_TAU_PRIOR_ALPHA, 8) &&
           VerifyField<double>(verifier, VT_SKYGRID_TAU_PRIOR_BETA, 8) &&
           VerifyField<uint8_t>(verifier, VT_SKYGRID_TAU_MOVE_ENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_SKYGRID_LOW_GAMMA_BARRIER_ENABLED, 1) &&
           VerifyField<double>(verifier, VT_SKYGRID_LOW_GAMMA_BARRIER_LOC, 8) &&
           VerifyField<double>(verifier, VT_SKYGRID_LOW_GAMMA_BARRIER_SCALE, 8) &&
           verifier.EndTable();
  }
};

template<> inline const delphy::api::ExpPopModel *Params::pop_model_as<delphy::api::ExpPopModel>() const {
  return pop_model_as_ExpPopModel();
}

template<> inline const delphy::api::SkygridPopModel *Params::pop_model_as<delphy::api::SkygridPopModel>() const {
  return pop_model_as_SkygridPopModel();
}

struct ParamsBuilder {
  typedef Params Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_step(int64_t step) {
    fbb_.AddElement<int64_t>(Params::VT_STEP, step, 0);
  }
  void add_num_local_moves_per_global_move(int64_t num_local_moves_per_global_move) {
    fbb_.AddElement<int64_t>(Params::VT_NUM_LOCAL_MOVES_PER_GLOBAL_MOVE, num_local_moves_per_global_move, -1LL);
  }
  void add_num_parts(int32_t num_parts) {
    fbb_.AddElement<int32_t>(Params::VT_NUM_PARTS, num_parts, 0);
  }
  void add_mu(double mu) {
    fbb_.AddElement<double>(Params::VT_MU, mu, 0.0);
  }
  void add_alpha(double alpha) {
    fbb_.AddElement<double>(Params::VT_ALPHA, alpha, 0.0);
  }
  void add_nu(::flatbuffers::Offset<::flatbuffers::Vector<double>> nu) {
    fbb_.AddOffset(Params::VT_NU, nu);
  }
  void add_hky_kappa(double hky_kappa) {
    fbb_.AddElement<double>(Params::VT_HKY_KAPPA, hky_kappa, 0.0);
  }
  void add_hky_pi_A(double hky_pi_A) {
    fbb_.AddElement<double>(Params::VT_HKY_PI_A, hky_pi_A, 0.0);
  }
  void add_hky_pi_C(double hky_pi_C) {
    fbb_.AddElement<double>(Params::VT_HKY_PI_C, hky_pi_C, 0.0);
  }
  void add_hky_pi_G(double hky_pi_G) {
    fbb_.AddElement<double>(Params::VT_HKY_PI_G, hky_pi_G, 0.0);
  }
  void add_hky_pi_T(double hky_pi_T) {
    fbb_.AddElement<double>(Params::VT_HKY_PI_T, hky_pi_T, 0.0);
  }
  void add_pop_n0(double pop_n0) {
    fbb_.AddElement<double>(Params::VT_POP_N0, pop_n0, 0.0);
  }
  void add_pop_g(double pop_g) {
    fbb_.AddElement<double>(Params::VT_POP_G, pop_g, 0.0);
  }
  void add_only_displacing_inner_nodes(bool only_displacing_inner_nodes) {
    fbb_.AddElement<uint8_t>(Params::VT_ONLY_DISPLACING_INNER_NODES, static_cast<uint8_t>(only_displacing_inner_nodes), 0);
  }
  void add_topology_moves_enabled(bool topology_moves_enabled) {
    fbb_.AddElement<uint8_t>(Params::VT_TOPOLOGY_MOVES_ENABLED, static_cast<uint8_t>(topology_moves_enabled), 0);
  }
  void add_repartitioning_enabled(bool repartitioning_enabled) {
    fbb_.AddElement<uint8_t>(Params::VT_REPARTITIONING_ENABLED, static_cast<uint8_t>(repartitioning_enabled), 0);
  }
  void add_alpha_move_enabled(bool alpha_move_enabled) {
    fbb_.AddElement<uint8_t>(Params::VT_ALPHA_MOVE_ENABLED, static_cast<uint8_t>(alpha_move_enabled), 0);
  }
  void add_log_posterior(double log_posterior) {
    fbb_.AddElement<double>(Params::VT_LOG_POSTERIOR, log_posterior, 0.0);
  }
  void add_log_other_priors(double log_other_priors) {
    fbb_.AddElement<double>(Params::VT_LOG_OTHER_PRIORS, log_other_priors, 0.0);
  }
  void add_log_coalescent_prior(double log_coalescent_prior) {
    fbb_.AddElement<double>(Params::VT_LOG_COALESCENT_PRIOR, log_coalescent_prior, 0.0);
  }
  void add_log_G(double log_G) {
    fbb_.AddElement<double>(Params::VT_LOG_G, log_G, 0.0);
  }
  void add_total_branch_length(double total_branch_length) {
    fbb_.AddElement<double>(Params::VT_TOTAL_BRANCH_LENGTH, total_branch_length, 0.0);
  }
  void add_mpox_hack_enabled(bool mpox_hack_enabled) {
    fbb_.AddElement<uint8_t>(Params::VT_MPOX_HACK_ENABLED, static_cast<uint8_t>(mpox_hack_enabled), 0);
  }
  void add_mpox_mu(double mpox_mu) {
    fbb_.AddElement<double>(Params::VT_MPOX_MU, mpox_mu, 0.0);
  }
  void add_mpox_mu_star(double mpox_mu_star) {
    fbb_.AddElement<double>(Params::VT_MPOX_MU_STAR, mpox_mu_star, 0.0);
  }
  void add_mu_move_enabled(bool mu_move_enabled) {
    fbb_.AddElement<uint8_t>(Params::VT_MU_MOVE_ENABLED, static_cast<uint8_t>(mu_move_enabled), 1);
  }
  void add_pop_t0(double pop_t0) {
    fbb_.AddElement<double>(Params::VT_POP_T0, pop_t0, 0.0);
  }
  void add_final_pop_size_move_enabled(bool final_pop_size_move_enabled) {
    fbb_.AddElement<uint8_t>(Params::VT_FINAL_POP_SIZE_MOVE_ENABLED, static_cast<uint8_t>(final_pop_size_move_enabled), 1);
  }
  void add_pop_growth_rate_move_enabled(bool pop_growth_rate_move_enabled) {
    fbb_.AddElement<uint8_t>(Params::VT_POP_GROWTH_RATE_MOVE_ENABLED, static_cast<uint8_t>(pop_growth_rate_move_enabled), 1);
  }
  void add_pop_model_type(delphy::api::PopModel pop_model_type) {
    fbb_.AddElement<uint8_t>(Params::VT_POP_MODEL_TYPE, static_cast<uint8_t>(pop_model_type), 0);
  }
  void add_pop_model(::flatbuffers::Offset<void> pop_model) {
    fbb_.AddOffset(Params::VT_POP_MODEL, pop_model);
  }
  void add_skygrid_tau(double skygrid_tau) {
    fbb_.AddElement<double>(Params::VT_SKYGRID_TAU, skygrid_tau, 0.0);
  }
  void add_skygrid_tau_prior_alpha(double skygrid_tau_prior_alpha) {
    fbb_.AddElement<double>(Params::VT_SKYGRID_TAU_PRIOR_ALPHA, skygrid_tau_prior_alpha, 0.0);
  }
  void add_skygrid_tau_prior_beta(double skygrid_tau_prior_beta) {
    fbb_.AddElement<double>(Params::VT_SKYGRID_TAU_PRIOR_BETA, skygrid_tau_prior_beta, 0.0);
  }
  void add_skygrid_tau_move_enabled(bool skygrid_tau_move_enabled) {
    fbb_.AddElement<uint8_t>(Params::VT_SKYGRID_TAU_MOVE_ENABLED, static_cast<uint8_t>(skygrid_tau_move_enabled), 0);
  }
  void add_skygrid_low_gamma_barrier_enabled(bool skygrid_low_gamma_barrier_enabled) {
    fbb_.AddElement<uint8_t>(Params::VT_SKYGRID_LOW_GAMMA_BARRIER_ENABLED, static_cast<uint8_t>(skygrid_low_gamma_barrier_enabled), 0);
  }
  void add_skygrid_low_gamma_barrier_loc(double skygrid_low_gamma_barrier_loc) {
    fbb_.AddElement<double>(Params::VT_SKYGRID_LOW_GAMMA_BARRIER_LOC, skygrid_low_gamma_barrier_loc, 0.0);
  }
  void add_skygrid_low_gamma_barrier_scale(double skygrid_low_gamma_barrier_scale) {
    fbb_.AddElement<double>(Params::VT_SKYGRID_LOW_GAMMA_BARRIER_SCALE, skygrid_low_gamma_barrier_scale, 0.0);
  }
  explicit ParamsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Params> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Params>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Params> CreateParams(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t step = 0,
    int64_t num_local_moves_per_global_move = -1LL,
    int32_t num_parts = 0,
    double mu = 0.0,
    double alpha = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<double>> nu = 0,
    double hky_kappa = 0.0,
    double hky_pi_A = 0.0,
    double hky_pi_C = 0.0,
    double hky_pi_G = 0.0,
    double hky_pi_T = 0.0,
    double pop_n0 = 0.0,
    double pop_g = 0.0,
    bool only_displacing_inner_nodes = false,
    bool topology_moves_enabled = false,
    bool repartitioning_enabled = false,
    bool alpha_move_enabled = false,
    double log_posterior = 0.0,
    double log_other_priors = 0.0,
    double log_coalescent_prior = 0.0,
    double log_G = 0.0,
    double total_branch_length = 0.0,
    bool mpox_hack_enabled = false,
    double mpox_mu = 0.0,
    double mpox_mu_star = 0.0,
    bool mu_move_enabled = true,
    double pop_t0 = 0.0,
    bool final_pop_size_move_enabled = true,
    bool pop_growth_rate_move_enabled = true,
    delphy::api::PopModel pop_model_type = delphy::api::PopModel_NONE,
    ::flatbuffers::Offset<void> pop_model = 0,
    double skygrid_tau = 0.0,
    double skygrid_tau_prior_alpha = 0.0,
    double skygrid_tau_prior_beta = 0.0,
    bool skygrid_tau_move_enabled = false,
    bool skygrid_low_gamma_barrier_enabled = false,
    double skygrid_low_gamma_barrier_loc = 0.0,
    double skygrid_low_gamma_barrier_scale = 0.0) {
  ParamsBuilder builder_(_fbb);
  builder_.add_skygrid_low_gamma_barrier_scale(skygrid_low_gamma_barrier_scale);
  builder_.add_skygrid_low_gamma_barrier_loc(skygrid_low_gamma_barrier_loc);
  builder_.add_skygrid_tau_prior_beta(skygrid_tau_prior_beta);
  builder_.add_skygrid_tau_prior_alpha(skygrid_tau_prior_alpha);
  builder_.add_skygrid_tau(skygrid_tau);
  builder_.add_pop_t0(pop_t0);
  builder_.add_mpox_mu_star(mpox_mu_star);
  builder_.add_mpox_mu(mpox_mu);
  builder_.add_total_branch_length(total_branch_length);
  builder_.add_log_G(log_G);
  builder_.add_log_coalescent_prior(log_coalescent_prior);
  builder_.add_log_other_priors(log_other_priors);
  builder_.add_log_posterior(log_posterior);
  builder_.add_pop_g(pop_g);
  builder_.add_pop_n0(pop_n0);
  builder_.add_hky_pi_T(hky_pi_T);
  builder_.add_hky_pi_G(hky_pi_G);
  builder_.add_hky_pi_C(hky_pi_C);
  builder_.add_hky_pi_A(hky_pi_A);
  builder_.add_hky_kappa(hky_kappa);
  builder_.add_alpha(alpha);
  builder_.add_mu(mu);
  builder_.add_num_local_moves_per_global_move(num_local_moves_per_global_move);
  builder_.add_step(step);
  builder_.add_pop_model(pop_model);
  builder_.add_nu(nu);
  builder_.add_num_parts(num_parts);
  builder_.add_skygrid_low_gamma_barrier_enabled(skygrid_low_gamma_barrier_enabled);
  builder_.add_skygrid_tau_move_enabled(skygrid_tau_move_enabled);
  builder_.add_pop_model_type(pop_model_type);
  builder_.add_pop_growth_rate_move_enabled(pop_growth_rate_move_enabled);
  builder_.add_final_pop_size_move_enabled(final_pop_size_move_enabled);
  builder_.add_mu_move_enabled(mu_move_enabled);
  builder_.add_mpox_hack_enabled(mpox_hack_enabled);
  builder_.add_alpha_move_enabled(alpha_move_enabled);
  builder_.add_repartitioning_enabled(repartitioning_enabled);
  builder_.add_topology_moves_enabled(topology_moves_enabled);
  builder_.add_only_displacing_inner_nodes(only_displacing_inner_nodes);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Params> CreateParamsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int64_t step = 0,
    int64_t num_local_moves_per_global_move = -1LL,
    int32_t num_parts = 0,
    double mu = 0.0,
    double alpha = 0.0,
    const std::vector<double> *nu = nullptr,
    double hky_kappa = 0.0,
    double hky_pi_A = 0.0,
    double hky_pi_C = 0.0,
    double hky_pi_G = 0.0,
    double hky_pi_T = 0.0,
    double pop_n0 = 0.0,
    double pop_g = 0.0,
    bool only_displacing_inner_nodes = false,
    bool topology_moves_enabled = false,
    bool repartitioning_enabled = false,
    bool alpha_move_enabled = false,
    double log_posterior = 0.0,
    double log_other_priors = 0.0,
    double log_coalescent_prior = 0.0,
    double log_G = 0.0,
    double total_branch_length = 0.0,
    bool mpox_hack_enabled = false,
    double mpox_mu = 0.0,
    double mpox_mu_star = 0.0,
    bool mu_move_enabled = true,
    double pop_t0 = 0.0,
    bool final_pop_size_move_enabled = true,
    bool pop_growth_rate_move_enabled = true,
    delphy::api::PopModel pop_model_type = delphy::api::PopModel_NONE,
    ::flatbuffers::Offset<void> pop_model = 0,
    double skygrid_tau = 0.0,
    double skygrid_tau_prior_alpha = 0.0,
    double skygrid_tau_prior_beta = 0.0,
    bool skygrid_tau_move_enabled = false,
    bool skygrid_low_gamma_barrier_enabled = false,
    double skygrid_low_gamma_barrier_loc = 0.0,
    double skygrid_low_gamma_barrier_scale = 0.0) {
  auto nu__ = nu ? _fbb.CreateVector<double>(*nu) : 0;
  return delphy::api::CreateParams(
      _fbb,
      step,
      num_local_moves_per_global_move,
      num_parts,
      mu,
      alpha,
      nu__,
      hky_kappa,
      hky_pi_A,
      hky_pi_C,
      hky_pi_G,
      hky_pi_T,
      pop_n0,
      pop_g,
      only_displacing_inner_nodes,
      topology_moves_enabled,
      repartitioning_enabled,
      alpha_move_enabled,
      log_posterior,
      log_other_priors,
      log_coalescent_prior,
      log_G,
      total_branch_length,
      mpox_hack_enabled,
      mpox_mu,
      mpox_mu_star,
      mu_move_enabled,
      pop_t0,
      final_pop_size_move_enabled,
      pop_growth_rate_move_enabled,
      pop_model_type,
      pop_model,
      skygrid_tau,
      skygrid_tau_prior_alpha,
      skygrid_tau_prior_beta,
      skygrid_tau_move_enabled,
      skygrid_low_gamma_barrier_enabled,
      skygrid_low_gamma_barrier_loc,
      skygrid_low_gamma_barrier_scale);
}

inline bool VerifyPopModel(::flatbuffers::Verifier &verifier, const void *obj, PopModel type) {
  switch (type) {
    case PopModel_NONE: {
      return true;
    }
    case PopModel_ExpPopModel: {
      auto ptr = reinterpret_cast<const delphy::api::ExpPopModel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PopModel_SkygridPopModel: {
      auto ptr = reinterpret_cast<const delphy::api::SkygridPopModel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPopModelVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPopModel(
        verifier,  values->Get(i), types->GetEnum<PopModel>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace api
}  // namespace delphy

#endif  // FLATBUFFERS_GENERATED_API_DELPHY_API_H_
